# Chapter02 객체지향 프로그래밍 
  
기술 서적에서 가장 어려운 점이 적당한 수준의 난이도와 복잡도를 유지하면서도 이해하기 쉬운 예제를 선택하는 것이다.  
지금 나오는 예제가 쉽더라도 충분히 복잡하고 난이도 있는 예제라고 생각하면서 읽어보기!  
  
## 01. 영화 예매 시스템   
### 요구사항 살펴보기  
이번 예제는 온라인 영화 예매 시스템이다.  
앞으로의 설명을 위해 '영화'와 '상영'을 구분한다.  
영화 : 영화에 대한 기본 정보 (제목, 상영시간, 가격정보)를 가리킨다.  
상영 : 실제로 관객들이 영화를 관람하는 사건을 표현한다.  
상영 일자, 시간, 순번 등을 가리키기 위해 '상영'이라는 용어를 사용할 것이다.   
  
두 용어의 차이가 중요한 이유는, 사용자가 실제로 예매하는 대상은 영화가 아니라 상영이기 때문이다.  
사람들은 영화를 예매한다고 하지만, 실제로는 특정 시간에 상영되는 영화를 관람할 수 있는 권리를 구매하는 것이다.  
  
특정 조건에서 영화 할인 가능  
- 할인 조건 
- 할인 정책
  
두 가지가 중요하다.   
  
할인을 적용하기 위해서는 할인 조건과 할인 정책을 함께 조합해서 사용한다.    
  
  
## 02. 객체지향 프로그래밍을 향해   
### 협력 객체 클래스  
대부분의 사람들은 어떤 **클래스**가 필요한지 결정하고, 클래스에 어떤 속성과 메서드가 필요한지 고민한다.  
  
안타깝지만 이것은 객체지향의 본질과는 거리가 멀다. 객체지향이란 말 그대로 객체를 지향하는 것이다.  
  
진정한 객체지향 패러다임으로의 전환은 클래스가 아닌 객체에 초점을 맞출 때에만 얻을 수 있다. 다음 두 가지에 집중해보자.  
> 1. 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하라.  
> 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화한 것이다.  
> 따라서 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 한다.  
> 객체를 중심에 두는 접근 방법은 설계를 단순하고 깔끔하게 만든다.  
  
> 2. 객체를 독립적인 존재가 아니라, 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 한다.  
> 객체는 홀로 존재하는것이 아니다. 다른 객체에게 도움을 주거나, 의존하면서 살아가는 협력적인 존재다.  
> 객체를 협력하는 공동체의 일원으로 바라보는 것은 설계를 유연하고 확장 가능하게 만든다.  
> 객체지향적으로 생각하고 싶다면, 객체를 고립된 존재로 바라보지 말고, 협력에 참여하는 협력자로 바라봐야 한다.  
> 객체들의 모양과 윤곽이 잡히면 공통된 특성과 상태를 가진 객체들을 타입으로 분류하고 이 타입을 기반으로 클래스를 구현해야 한다.  
  
  
### 도메인의 구조를 따르는 프로그램 구조  
이 시점에 **도메인(domain)** 이라는 용어를 살펴보는 것이 도움이 될것이다.   
  
영화 예매 시스템의 목적은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하는 것이다.  
이처럼 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 **도메인** 이라고 한다.   
<img width="681" alt="스크린샷 2023-02-04 오후 7 06 14" src="https://user-images.githubusercontent.com/115435784/216761213-2dde3411-684c-4b94-a5b9-dab1258f911f.png">
  
영화는 여러번 상영될 수 있고, 상영은 여러번 예매될 수 있다는 것을 알 수 있다...? (이 그림보고 어떻게 아는거지?)
  
일반적으로 클래스의 이름은 대응되는 도메인 개념의 이름과 동일하거나 적어도 유사하게 지어야 한다.  
<img width="670" alt="스크린샷 2023-02-04 오후 7 11 22" src="https://user-images.githubusercontent.com/115435784/216761414-5b6bbf93-27a6-47c3-945e-f67c32dc445f.png">
  
### 클래스 구현하기    
```java
package org.example.chapter02.movie;

import java.time.LocalDateTime;

public class Screening {
    private Movie movie;
    private int sequence;
    private LocalDateTime whenScreened;

    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
        this.movie = movie;
        this.sequence = sequence;
        this.whenScreened = whenScreened;
    }

    public LocalDateTime getStartTime() {
        return whenScreened;
    }

    public boolean isSequence(int sequence) {
        return this.sequence == sequence;
    }

    public Movey getMovieFee() {
        return movie.getFee();
    }
}
```  
여기서 주목할 점은 필드의 접근제어자는 private 이고, 메서드의 접근제어자는 public 이라는 것이다.  
클래스를 구현할 때 중요한 것은 클래스의 경계를 구분짓는 것이다.   
클래스의 경계는 내부와 외부로 구분되고, 훌륭한 클래스를 설계하기 위해서는 어느 부분을 외부에 공개할 것인지, 어떤 부분을 감출 것인지 결정하는 것이다.  
  
클래스의 내부와 외부의 구분해야 하는 이유는? 
> 경계의 명확성이 객체의 자율성을 보장하기 때문이다.  
> 더 중요한 이유로 프로그래머에게 구현의 자유를 제공하기 때문이다.  
  
### 자율적인 객체  
- 객체는 **상태(state)와 행동(behavior)** 을 함께 가지는 복합적인 존재이다.  
- 객체가 스스로 판단하고 행동하는 **자율적인 존재** 이다.  
위 두 가지는 깊이 연관되어 있다.  
   
객체지향 이전 패러다임에서는 데이터와 기능이라는 독립적인 존재를 서로 엮어 프로그램을 구성했다.  
이와 달리 객체지향은 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶었다.  
이처럼 데이터와 기능을 한 덩어리 내부로 함께 묶는 것을 **캡슐화** 라고 한다.   
  
**인터페이스와 구현의 분리**  
역할을 인터페이스로 나타내고, 
행동을 인터페이스를 구현한 클래스로 나타낸다.  
이는 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.  
  
### 프로그래머의 자유  
프로그래머의 역할 
- **클래스 작성자(class creator)**
- **클라이언트 프로그래머(client programmer)**
  
클래스 작성자는 새로운 데이터 타입을 프로그램에 추가하고, 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입을 사용한다.  
  
클래스 작성자는 클라이언트 프로그래머에게 필요한 부분만 공개하고, 나머지는 꽁꽁 숨기는 **캡슐화**를 해야 한다.  
이 덕분에 클라이언트 프로그래머는 내부 영향을 걱정하지 않고 내부 구현을 마음대로 변경할 수 있다.  
이를 **구현 은닉(implementation hiding)**이라고 한다.  
  
### 협력하는 객체들의 공동체  
```java
public class Screening {
    public Reservation reserve(Customer customer, int audiencCount) {
        return new Reservation(customer, this, calculateFee(audiencCount), audiencCount);
    }
}
```  
Screening의 reserve 메서드를 보면 calculateFee라는 private 메서드를 호출해서 요금을 계산한 후 그 결과를 Reservation의 생성자에 전달한다.  
  
영화를 예매하기 위해 Screening, Movie, Reservation 인스턴스들은 서로의 메서드를 호출하며 상호작용한다.  
이처럼 객체들 사이의 상호작용을 **협력(Collaboration)**이라고 한다.  
  
### 협력에 관한 짧은 이야기  
앞에서 설명한 것 처럼 객체의 내부 상태는 외부에서 접근하지 못하도록 감춰야 한다.  
대신 외부에 공개하는 퍼블릭 인터페이스를 통해 내부 상태에 접근할 수 있도록 허용한다.  
  
객체가 다른 객체와 상호작용 할 수 있는 방법은 **메시지를 전송하고 메시지를 수신**하는 방법 뿐이다.  
**메서드**는 수신된 메시지를 처리하기 위한 자신만의 방법이다.  
  
